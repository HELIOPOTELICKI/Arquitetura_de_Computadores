; I/O Address Bus decode - every device gets 0x200 addresses */

IO0  EQU  0000h
IO1  EQU  0200h
IO2  EQU  0400h
IO3  EQU  0600h
IO4  EQU  0800h
IO5  EQU  0A00h
IO6  EQU  0C00h
IO7  EQU  0E00h
IO8  EQU  1000h
IO9  EQU  1200h
IO10 EQU  1400h
IO11 EQU  1600h
IO12 EQU  1800h
IO13 EQU  1A00h
IO14 EQU  1C00h
IO15 EQU  1E00h

; 8251A USART 

ADR_USART_DATA EQU  (IO4 + 00h)
;ONDE VOCE VAI MANDAR E RECEBER DADOS DO 8251

ADR_USART_CMD  EQU  (IO4 + 02h)
;É O LOCAL ONDE VOCE VAI ESCREVER PARA PROGRAMAR O 8251

ADR_USART_STAT EQU  (IO4 + 02h)
;RETORNA O STATUS SE UM CARACTER FOI DIGITADO
;RETORNA O STATUS SE POSSO TRANSMITIR CARACTER PARA O TERMINAL


; 8251A USART 2

ADR_USART_DATA_2 EQU  (IO5 + 00h)
;ONDE VOCE VAI MANDAR E RECEBER DADOS DO 8251

ADR_USART_CMD_2  EQU  (IO5 + 02h)
;É O LOCAL ONDE VOCE VAI ESCREVER PARA PROGRAMAR O 8251

ADR_USART_STAT_2 EQU  (IO5 + 02h)
;RETORNA O STATUS SE UM CARACTER FOI DIGITADO
;RETORNA O STATUS SE POSSO TRANSMITIR CARACTER PARA O TERMINAL


;MEU CODIGO
code      SEGMENT 'code'
	  assume    CS:code,DS:data,SS:stack,ES:extra

	  Org 0008H
	  PONTEIRO_TRATADOR_INTERRUPCAO DB 4 DUP("P") ; PONTEIRO PARA INTERRUPCAO	

;RESERVADO PARA VETOR DE INTERRUPCOES
	  org 0400H

CONVERTE_10_BITS:
	RCR BH,1
	JC  ACENDE_LSB
	AND BL,01111111B
	JMP CONVERTED_10_BITS
ACENDE_LSB:
	OR BL,10000000B
CONVERTED_10_BITS:
	RET

INICIALIZA_8251:                                     
   MOV AL,0
   MOV DX, ADR_USART_CMD
   OUT DX,AL
   OUT DX,AL
   OUT DX,AL
   MOV AL,40H
   OUT DX,AL
   MOV AL,4DH
   OUT DX,AL
   MOV AL,37H
   OUT DX,AL
   RET

RECEBE_CARACTER:
   PUSHF
   PUSH DX
AGUARDA_CARACTER:
   MOV DX, ADR_USART_STAT
   IN  AL,DX
   TEST AL,2
   JZ AGUARDA_CARACTER
   MOV DX, ADR_USART_DATA
   IN AL,DX
   ;SHR AL,1
NAO_RECEBIDO:
   POP DX
   POPF
   RET

MANDA_CARACTER:
   PUSHF
   PUSH DX
   PUSH AX  ; SALVA AL   
BUSY:
   MOV DX, ADR_USART_STAT
   IN  AL,DX
   TEST AL,1
   JZ BUSY
   MOV DX, ADR_USART_DATA
   POP AX  ; RESTAURA AL
   OUT DX,AL
   POP DX
   POPF
   RET 


INICIALIZA_8251_2:                                     
   MOV AL,0
   MOV DX, ADR_USART_CMD_2
   OUT DX,AL
   OUT DX,AL
   OUT DX,AL
   MOV AL,40H
   OUT DX,AL
   MOV AL,4DH
   OUT DX,AL
   MOV AL,37H
   OUT DX,AL
   RET

RECEBE_CARACTER_2:
   PUSHF
   PUSH DX
AGUARDA_CARACTER_2:
   MOV DX, ADR_USART_STAT_2
   IN  AL,DX
   TEST AL,2
   JZ AGUARDA_CARACTER_2
   MOV DX, ADR_USART_DATA_2
   IN AL,DX
   ;SHR AL,1
NAO_RECEBIDO_2:
   POP DX
   POPF
   RET

MANDA_CARACTER_2:
   PUSHF
   PUSH DX
   PUSH AX  ; SALVA AL   
BUSY_2:
   MOV DX, ADR_USART_STAT_2
   IN  AL,DX
   TEST AL,1
   JZ BUSY_2
   MOV DX, ADR_USART_DATA_2
   POP AX  ; RESTAURA AL
   OUT DX,AL
   POP DX
   POPF
   RET 


DELAY:
	MOV CX,65535
DELAY_1:
	LOOP DELAY_1
	RET

MAIUSCULO:
   PUSHF
   PUSH AX
MAIUSCULO_COMPARA:
   MOV AL,[BX]
   CMP AL,0
   JE FIM_MAIUSCULO
   CMP AL,"a"
   JL MAIUSCULO_IGNORA
   CMP AL,"z"
   JG MAIUSCULO_IGNORA
   SUB AL,32
   MOV [BX],AL
   INC BX
   JMP MAIUSCULO_COMPARA
MAIUSCULO_IGNORA:
   INC BX
   JMP MAIUSCULO_COMPARA
FIM_MAIUSCULO:
   POP AX
   POPF
   RET

IMPRIME_TEXTO:
MANDA:
	MOV AL, [BX]
	CMP AL, 0 ; null ou indicador de fim de texto
	JE  FINALIZA
	CALL MANDA_CARACTER
	ADD BX,1 ; inc bx
	JMP MANDA
FINALIZA:
	RET

IMPRIME_TEXTO_2:
MANDA_2:
	MOV AL, [BX]
	CMP AL, 0 ; null ou indicador de fim de texto
	JE  FINALIZA
	CALL MANDA_CARACTER_2
	ADD BX,1 ; inc bx
	JMP MANDA_2
FINALIZA_2:
	RET

MANDA_FIRMATA:
MANDA_FIRM:
	MOV AL, [BX]
	CMP AL, 0F7H ; null ou indicador de fim de texto
	JE  FINALIZA_FIRM
	CALL MANDA_CARACTER
	ADD BX,1 ; inc bx
	JMP MANDA_FIRM
FINALIZA_FIRM:
	RET

ENTRADA:
	MOV CL,0
	MOV BX, OFFSET TEXTO_DIGITADO	
LE_TECLA:
	CALL RECEBE_CARACTER ;AL VAI TER CARACTER
	CMP AL, 13
	JE  PRESSIONOU_13
	CMP AL,8 
	JE  BACKSPACE

	CMP CL, 80
	JE  LE_TECLA
	
	CALL MANDA_CARACTER ;QUE ESTA EM AL	
	MOV [BX], AL
	INC BX
	INC CL
	JMP LE_TECLA
		
PRESSIONOU_13:

	MOV AL,0
	MOV [BX],AL
	RET

	
BACKSPACE:
      CMP CL, 0
      JE  LE_TECLA
      CALL MANDA_CARACTER ;QUE ESTA EM AL
      DEC CL
      DEC BX
      JMP LE_TECLA


;MEU CODIGO
inicio:

	MOV AX,0    
	MOV DS, AX ;FAZ O DS APONTAR PARA O SEGMENTO 0000

	MOV WORD PTR PONTEIRO_TRATADOR_INTERRUPCAO,     OFFSET SYSTICK
	MOV WORD PTR PONTEIRO_TRATADOR_INTERRUPCAO + 2, SEG    SYSTICK

    MOV AX,DATA ;JOGA EM AX O NUMERO DO SEGMENTO ALOCADO PARA DATA
    MOV DS,AX   ;MOVA AX PARA DS, OU SEJA, DS AGORA APONTA PARA
                ;AQUELE SEGMENTO
	MOV AX,EXTRA ; FAZ COM O REGISTRADORES APONTE PARA O SEGMENTO 
	MOV ES,AX

; FACA A ROTINA QUE JUNTE LSB COM MSB E FORME UM UNICO NUMERO DE 10 BITS E COLOQUE EM BX

	CALL DELAY

	;CALL INICIALIZA_8251
	CALL INICIALIZA_8251_2

	MOV BX, OFFSET MENSAGEM
	CALL IMPRIME_TEXTO_2

ACABOU: 	JMP ACABOU


	;MOV BX, OFFSET CMD_INIT_RGB_13
	;CALL MANDA_FIRMATA

	MOV BX, OFFSET CMD_INIT_ANALOG_A0
	CALL MANDA_FIRMATA

	;MOV BX, OFFSET CMD_SET_ON_13
	;CALL MANDA_FIRMATA

	;MOV BX, OFFSET CMD_SET_OFF_13
	;CALL MANDA_FIRMATA

	;MOV BX, OFFSET CMD_READ_ANALOG_0
	;CALL MANDA_FIRMATA
	
LE_AD:
	CALL RECEBE_CARACTER	
	AND AL,10000000B
	CMP AL,10000000B  ; INICIO PACOTE
    JNE LE_AD
INICIO_PACOTE:
	CALL RECEBE_CARACTER	
	SHR AL,1
	MOV LSB,AL
	CALL RECEBE_CARACTER	
	SHR AL,1
	MOV MSB,AL
	CALL CONVERTE_10_BITS  ; RETORNA EM BX O DADO DIGITAL EM 10 BITS

	JMP LE_AD

SYSTICK:
    IRET		
code ends

;MILHA PILHA
STACK SEGMENT STACK      
DW 128 DUP("*") 
STACK ENDS 

;MEUS DADOS
DATA      SEGMENT  
MENSAGEM  DB "*************ABABABABABABABABABABABABABABABABABAB*************",13,10,0
MENSAGEM2 DB "PRESS ANY KEY TO CONTINUE",13,10,0
MENSAGEM3 DB "THANKS",13,10,0
MENSAGEM4 DB "AbAbAbAbAbAbAbAbAbAbAbAbAbAbAbAbAbAbAbAbAbAbAbAbAb%38381123@3",13,10,0
TEXTO_DIGITADO DB 81 DUP(" ")

CMD_INIT_RGB_10   DB 0F4H, 10, 1, 0F7H
CMD_INIT_RGB_11   DB 0F4H, 11, 1, 0F7H
CMD_INIT_RGB_12   DB 0F4H, 12, 1, 0F7H
CMD_INIT_RGB_13   DB 0F4H, 13, 1, 0F7H
CMD_SET_ON_10     DB 0F5H, 10, 1, 0F7H
CMD_SET_OFF_10    DB 0F5H, 10, 0, 0F7H
CMD_SET_ON_11     DB 0F5H, 11, 1, 0F7H
CMD_SET_OFF_11    DB 0F5H, 11, 0, 0F7H
CMD_SET_ON_12     DB 0F5H, 12, 1, 0F7H
CMD_SET_OFF_12    DB 0F5H, 12, 0, 0F7H
CMD_SET_ON_13     DB 0F5H, 13, 1, 0F7H
CMD_SET_OFF_13    DB 0F5H, 13, 0, 0F7H

CMD_INIT_ANALOG_A0 DB 0F4H, 14, 2, 0F7H

LSB DB 7FH
MSB DB 07H

DATA      ENDS

EXTRA SEGMENT
EXTRA ENDS

end inicio
